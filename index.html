<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLSL Shader Viewer - Fullscreen</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        #glslCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="glslCanvas"></canvas>
    
    <script id="vertex-shader" type="x-shader/x-vertex">
#version 300 es 
in vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0); 
}
    </script>

    <script id="draw-screen-shader" type="x-shader/x-fragment">
#version 300 es
precision mediump float;
uniform vec2 iResolution;
uniform sampler2D u_frame;
out vec4 fragColorOut;

void main() {
    vec2 uv = gl_FragCoord.xy / iResolution.xy;
    vec4 source_color = texture(u_frame, uv); 
    
    // Monochrome Output
    float mono = (source_color.r + source_color.g + source_color.b) / 3.0;
    fragColorOut = vec4(vec3(mono), 1.0);
}
    </script>

    <script id="feedback-shader" type="x-shader/x-fragment">
#version 300 es 
precision mediump float;
uniform vec2 iResolution;
uniform float iTime;
uniform float u_scale;
uniform float u_density;
uniform float u_thickness;
uniform float u_scrollSpeed;
uniform float u_warpSpeed;
uniform float u_recursion;
uniform float u_glitchIntensity;
uniform int u_rotation1; 
uniform int u_rotation2; 
uniform int u_globalRotation;
uniform sampler2D u_prevFrame;

out vec4 fragColorOut;

vec3 hash3( vec2 p ) {
    vec3 q = vec3( dot(p,vec2(127.1,311.7)), 
                   dot(p,vec2(269.5,183.3)), 
                   dot(p,vec2(419.2,371.9)) );
    return fract(sin(q)*43758.5453);
}

const float PHI = 1.61803398874989484820459;

vec2 rotateVec(vec2 v, int rot) {
    if (rot == 1) { return vec2(-v.y, v.x); } 
    if (rot == 2) { return vec2(-v.x, -v.y); } 
    if (rot == 3) { return vec2(v.y, -v.x); } 
    return v; 
}

vec2 getShiftDir(vec2 coord, float time_seed, float glitchStrength) {
    vec2 R = iResolution.xy;
    vec2 p = coord / R;
    vec2 shift_dir = vec2(0.0);
    vec2 center = vec2(0.5);

    float recursion_depth = floor(u_recursion);

    for (int i = 0; i < 10; i++) {
        if (float(i) >= recursion_depth) break;
        
        vec2 cell_hash_base = hash3(center * (float(i) + 1.0) + time_seed).xy;
        vec2 cell_hash = fract(cell_hash_base + floor(hash3(center * 5.0 + iTime * 0.1).x * glitchStrength * 0.1));
        
        if (p.x > center.x) { center.x += (1.0 - center.x) / PHI; } else { center.x -= center.x / PHI; }
        if (p.y > center.y) { center.y += (1.0 - center.y) / PHI; } else { center.y -= center.y / PHI; }
        
        float hash_val = cell_hash.x;

        if (hash_val < 0.25) { shift_dir = vec2(1.0, 0.0); }
        else if (hash_val < 0.5) { shift_dir = vec2(-1.0, 0.0); }
        else if (hash_val < 0.75) { shift_dir = vec2(0.0, 1.0); }
        else { shift_dir = vec2(0.0, -1.0); }
    }
    return shift_dir;
}

float getPatternValue(vec2 coord, float timeOffset) {
     float t = iTime + timeOffset;
     float pattern_noise_offset_x = floor(hash3(coord * 0.01 + t * 0.5).x * u_glitchIntensity * 0.2);
     float pattern_noise_offset_y = floor(hash3(coord * 0.02 - t * 0.3).y * u_glitchIntensity * 0.15);

     int x = int(coord.x + pattern_noise_offset_x);
     int y = int(coord.y + u_scrollSpeed * t + pattern_noise_offset_y);
     int r = (x+y)^(x-y); 

     int denominator = y+x+int(t*u_warpSpeed);
     if (denominator == 0) { denominator = 1; }
     
     int r_powered = int(pow(float(abs(r)), u_density));
     float scaled_r = float(abs(r_powered)) / float(denominator);
     bool b = mod(scaled_r, u_scale) < u_thickness;

     return b ? 1.0 : 0.0;
}

vec2 applyRotation(vec2 coord, int rotation) {
    if (rotation == 0) { return coord; }
    if (rotation == 1) { return vec2(coord.y, -coord.x + iResolution.y); }
    if (rotation == 2) { return vec2(-coord.x + iResolution.x, -coord.y + iResolution.y); }
    if (rotation == 3) { return vec2(-coord.y + iResolution.x, coord.x); }
    return coord; 
}

void main() {
    float time_seed = floor(iTime * 0.5 + floor(hash3(vec2(iTime * 10.0, 0.0)).x * u_glitchIntensity * 0.05));
    vec2 coord = gl_FragCoord.xy;
    vec2 current_frag_coord = coord;

    if (fract(iTime * 1.5 + current_frag_coord.y * 0.01 + hash3(vec2(current_frag_coord.y, iTime)).x) < (u_glitchIntensity * 0.005)) { 
        float shift_amount = floor(hash3(vec2(iTime * 10.0, current_frag_coord.y)).x * u_glitchIntensity * 1.0);
        current_frag_coord.x += shift_amount;
    }
    
    vec2 shift_dir = getShiftDir(current_frag_coord, time_seed, u_glitchIntensity);
    vec2 pixel_drift_hash = hash3(gl_FragCoord.xy * 0.05 + iTime * 0.5).xy;
    vec2 pixel_drift = floor((pixel_drift_hash - 0.5) * u_glitchIntensity * 0.4); 
    
    shift_dir = rotateVec(shift_dir, u_globalRotation);
    pixel_drift = rotateVec(pixel_drift, u_globalRotation);

    vec2 smear_coord = current_frag_coord + shift_dir + pixel_drift; 
    
    vec3 prevFrame = texture(u_prevFrame, smear_coord / iResolution.xy).rgb;
    prevFrame *= 0.92;

    vec2 coord1 = applyRotation(coord, u_rotation1);
    float layer1 = getPatternValue(coord1, 0.0);
    vec2 coord2 = applyRotation(coord, u_rotation2);
    float layer2 = getPatternValue(coord2, 0.0);

    float patternValue = layer1 * layer2; 
    patternValue *= 1.1; 

    vec3 finalColor = max(prevFrame, vec3(patternValue)); 
    float mono = (finalColor.r + finalColor.g + finalColor.b) / 3.0;
    
    fragColorOut = vec4(vec3(clamp(mono, 0.0, 1.0)), 1.0);
}
    </script>
    
    <script>
    window.addEventListener('DOMContentLoaded', () => {
        const CONFIG = {
            U_SCALE: 17730.0, U_DENSITY: 3.0, U_THICKNESS: 1950.0,
            U_SCROLL_SPEED: 38.0, U_WARP_SPEED: 68.0,
            U_RECURSION: 5.0, U_GLITCH_INTENSITY: 25.0,
            CYCLE_DURATION: 240.0, 
            FORWARD_PHASE: 120.0,
        };
        
        const canvas = document.getElementById('glslCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            document.body.innerHTML = "WebGL 2 not supported.";
            return; 
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            return program;
        }
        
        function createFBO(gl, width, height) {
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            return { fbo, texture, width, height };
        }

        const vs = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
        const fsFb = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('feedback-shader').text);
        const fsDs = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('draw-screen-shader').text);
        
        const feedbackProgram = createProgram(gl, vs, fsFb);
        const drawScreenProgram = createProgram(gl, vs, fsDs);

        let fbo1, fbo2;
        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            canvas.width = w;
            canvas.height = h;
            
            // Re-create FBOs to match screen size for crisp feedback
            if (fbo1) {
                gl.deleteFramebuffer(fbo1.fbo);
                gl.deleteTexture(fbo1.texture);
                gl.deleteFramebuffer(fbo2.fbo);
                gl.deleteTexture(fbo2.texture);
            }
            fbo1 = createFBO(gl, w, h);
            fbo2 = createFBO(gl, w, h);
        }

        window.addEventListener('resize', resize);
        resize();

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        const fbLocs = {
            iRes: gl.getUniformLocation(feedbackProgram, "iResolution"),
            iTime: gl.getUniformLocation(feedbackProgram, "iTime"),
            uRot1: gl.getUniformLocation(feedbackProgram, "u_rotation1"),
            uRot2: gl.getUniformLocation(feedbackProgram, "u_rotation2"),
            uGlobalRot: gl.getUniformLocation(feedbackProgram, "u_globalRotation"),
            uPrevFrame: gl.getUniformLocation(feedbackProgram, "u_prevFrame"),
            aPosition: gl.getAttribLocation(feedbackProgram, "a_position")
        };
        
        const dsLocs = {
            iRes: gl.getUniformLocation(drawScreenProgram, "iResolution"),
            uFrame: gl.getUniformLocation(drawScreenProgram, "u_frame"),
            aPosition: gl.getAttribLocation(drawScreenProgram, "a_position")
        };
        
        let currentRotation1 = 0, currentRotation2 = 1, currentGlobalRotation = 0;
        let nextGlobalRotationTime = 0, lastRandomizeTime = 0.0;

        function randomizeRotations() {
            currentRotation1 = Math.floor(Math.random() * 4);
            do { currentRotation2 = Math.floor(Math.random() * 4); } while (currentRotation1 === currentRotation2);
        }
        randomizeRotations();

        function render(time_ms) {
            let totalTime = time_ms * 0.001; 
            let cycleTime = totalTime % CONFIG.CYCLE_DURATION;
            let animationTime = cycleTime <= CONFIG.FORWARD_PHASE ? cycleTime : CONFIG.FORWARD_PHASE - (cycleTime - CONFIG.FORWARD_PHASE);

            if (totalTime - lastRandomizeTime > 5.0) {
                randomizeRotations();
                lastRandomizeTime = totalTime;
            }
            if (totalTime > nextGlobalRotationTime) {
                currentGlobalRotation = Math.floor(Math.random() * 4);
                nextGlobalRotationTime = totalTime + (Math.random() * 4.0 + 3.0);
            }
            
            // Pass 1: Feedback
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2.fbo);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(feedbackProgram);
            
            gl.uniform2f(fbLocs.iRes, canvas.width, canvas.height);
            gl.uniform1f(fbLocs.iTime, animationTime);
            gl.uniform1i(fbLocs.uRot1, currentRotation1);
            gl.uniform1i(fbLocs.uRot2, currentRotation2);
            gl.uniform1i(fbLocs.uGlobalRot, currentGlobalRotation);
            
            // Set static config uniforms inside loop to ensure they persist across program switches
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_scale"), CONFIG.U_SCALE);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_density"), CONFIG.U_DENSITY);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_thickness"), CONFIG.U_THICKNESS);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_scrollSpeed"), CONFIG.U_SCROLL_SPEED);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_warpSpeed"), CONFIG.U_WARP_SPEED);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_recursion"), CONFIG.U_RECURSION);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_glitchIntensity"), CONFIG.U_GLITCH_INTENSITY);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo1.texture); 
            gl.uniform1i(fbLocs.uPrevFrame, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(fbLocs.aPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(fbLocs.aPosition);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Pass 2: Draw to Screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(drawScreenProgram);
            
            gl.uniform2f(dsLocs.iRes, canvas.width, canvas.height);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo2.texture); 
            gl.uniform1i(dsLocs.uFrame, 0);

            gl.vertexAttribPointer(dsLocs.aPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(dsLocs.aPosition);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            [fbo1, fbo2] = [fbo2, fbo1];
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
    });
    </script>
</body>
</html>
