<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLSL Shader Viewer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #glslCanvas {
            width: 1024px;
            height: 1024px;
        }
    </style>
</head>
<body>
    <canvas id="glslCanvas"></canvas>
    
    
<script id="vertex-shader" type="x-shader/x-vertex">
#version 300 es 
in vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0); 
}
    </script>

    
<script id="draw-screen-shader" type="x-shader/x-fragment">
#version 300 es
precision mediump float;
uniform vec2 iResolution;
uniform sampler2D u_frame;
out vec4 fragColorOut;

void main() {
    vec2 coord = gl_FragCoord.xy;
    float border = 16.0;

    // Apply 16px solid black border
    if (coord.x < border || 
        coord.x > iResolution.x - border ||
        coord.y < border || 
        coord.y > iResolution.y - border) 
    {
        fragColorOut = vec4(0.0, 0.0, 0.0, 1.0); // Black
        return;
    } 

    // Sample internal FBO texture (LDR)
    vec2 uv = coord / iResolution.xy;
    vec4 source_color = texture(u_frame, uv); 
    
    // Ensure Monochrome Output
    float mono = (source_color.r + source_color.g + source_color.b) / 3.0;
    
    // REMOVED: Gamma Correction
    // float gamma = 0.92; 
    // mono = pow(mono, gamma);
    
    fragColorOut = vec4(vec3(mono), 1.0);
}
    </script>


    
<script id="feedback-shader" type="x-shader/x-fragment">
#version 300 es 
precision mediump float;
uniform vec2 iResolution;
uniform float iTime;
uniform float u_scale;
uniform float u_density;
uniform float u_thickness;
uniform float u_scrollSpeed;
uniform float u_warpSpeed;
uniform float u_recursion;
uniform float u_glitchIntensity;
uniform int u_rotation1; 
uniform int u_rotation2; 
uniform int u_globalRotation;
uniform sampler2D u_prevFrame;

out vec4 fragColorOut;

// Simple 2D hash function
vec3 hash3( vec2 p ) {
    vec3 q = vec3( dot(p,vec2(127.1,311.7)), 
                   dot(p,vec2(269.5,183.3)), 
                   dot(p,vec2(419.2,371.9)) );
    return fract(sin(q)*43758.5453);
}

const float PHI = 1.61803398874989484820459; // Golden Ratio

// Rotate vector by 90-degree increments
vec2 rotateVec(vec2 v, int rot) {
    if (rot == 1) { return vec2(-v.y, v.x); } 
    if (rot == 2) { return vec2(-v.x, -v.y); } 
    if (rot == 3) { return vec2(v.y, -v.x); } 
    return v; 
}

// Recursive function for Fibonacci-based cell pushing
vec2 getShiftDir(vec2 coord, float time_seed, float glitchStrength) {
    vec2 R = iResolution.xy;
    vec2 p = coord / R;
    vec2 shift_dir = vec2(0.0);
    vec2 center = vec2(0.5);

    float recursion_depth = floor(u_recursion);

    for (int i = 0; i < 10; i++) {
        if (float(i) >= recursion_depth) break;
        
        // Blocky noise for unstable cell boundaries
        vec2 cell_hash_base = hash3(center * (float(i) + 1.0) + time_seed).xy;
        vec2 cell_hash = fract(cell_hash_base + floor(hash3(center * 5.0 + iTime * 0.1).x * glitchStrength * 0.1));
        
        // Split based on golden ratio
        if (p.x > center.x) { center.x += (1.0 - center.x) / PHI; } else { center.x -= center.x / PHI; }
        if (p.y > center.y) { center.y += (1.0 - center.y) / PHI; } else { center.y -= center.y / PHI; }
        
        float hash_val = cell_hash.x;

        // H/V Tearing Only (no diagonals)
        if (hash_val < 0.25) { shift_dir = vec2(1.0, 0.0); }
        else if (hash_val < 0.5) { shift_dir = vec2(-1.0, 0.0); }
        else if (hash_val < 0.75) { shift_dir = vec2(0.0, 1.0); }
        else { shift_dir = vec2(0.0, -1.0); }
    }
    return shift_dir;
}

// Core fractal pattern generation (bitwise XOR)
float getPatternValue(vec2 coord, float timeOffset) {
     float t = iTime + timeOffset;
     
     // Pattern distortion based on glitch intensity
     float pattern_noise_offset_x = floor(hash3(coord * 0.01 + t * 0.5).x * u_glitchIntensity * 0.2);
     float pattern_noise_offset_y = floor(hash3(coord * 0.02 - t * 0.3).y * u_glitchIntensity * 0.15);

     int x = int(coord.x + pattern_noise_offset_x);
     int y = int(coord.y + u_scrollSpeed * t + pattern_noise_offset_y);
     
     // Bitwise XOR math (WebGL2 only)
     int r = (x+y)^(x-y); 

     int denominator = y+x+int(t*u_warpSpeed);
     if (denominator == 0) { denominator = 1; }
     
     int r_powered = int(pow(float(abs(r)), u_density));
     
     // Final threshold for white/black pixel
     float scaled_r = float(abs(r_powered)) / float(denominator);
     bool b = mod(scaled_r, u_scale) < u_thickness;

     return b ? 1.0 : 0.0;
}

// Rotate pattern coordinates
vec2 applyRotation(vec2 coord, int rotation) {
    if (rotation == 0) { return coord; }
    if (rotation == 1) { return vec2(coord.y, -coord.x + iResolution.y); }
    if (rotation == 2) { return vec2(-coord.x + iResolution.x, -coord.y + iResolution.y); }
    if (rotation == 3) { return vec2(-coord.y + iResolution.x, coord.x); }
    return coord; 
}


void main() {
    // Stuttering time seed for cell changes
    float time_seed = floor(iTime * 0.5 + floor(hash3(vec2(iTime * 10.0, 0.0)).x * u_glitchIntensity * 0.05));
    
    // Base coordinate
    vec2 coord = gl_FragCoord.xy;
    vec2 current_frag_coord = coord;

    // Glitch / Screen Tears (shifts pixels horizontally)
    if (fract(iTime * 1.5 + current_frag_coord.y * 0.01 + hash3(vec2(current_frag_coord.y, iTime)).x) < (u_glitchIntensity * 0.005)) { 
        float shift_amount = floor(hash3(vec2(iTime * 10.0, current_frag_coord.y)).x * u_glitchIntensity * 1.0);
        current_frag_coord.x += shift_amount;
    }
    
    // Apply primary shift direction from recursive cells
    vec2 shift_dir = getShiftDir(current_frag_coord, time_seed, u_glitchIntensity);
    
    // Add additional pixel drift/smear
    vec2 pixel_drift_hash = hash3(gl_FragCoord.xy * 0.05 + iTime * 0.5).xy;
    vec2 pixel_drift = floor((pixel_drift_hash - 0.5) * u_glitchIntensity * 0.4); 
    
    // Apply global rotation to feedback vectors
    shift_dir = rotateVec(shift_dir, u_globalRotation);
    pixel_drift = rotateVec(pixel_drift, u_globalRotation);

    vec2 smear_coord = current_frag_coord + shift_dir + pixel_drift; 
    
    // Feedback Pass
    vec3 prevFrame = texture(u_prevFrame, smear_coord / iResolution.xy).rgb;
    prevFrame *= 0.92; // Fade level

    // Generate Layer 1 & 2
    vec2 coord1 = applyRotation(coord, u_rotation1);
    float layer1 = getPatternValue(coord1, 0.0);
    vec2 coord2 = applyRotation(coord, u_rotation2);
    float layer2 = getPatternValue(coord2, 0.0);

    float patternValue = layer1 * layer2; // Multiply blend
    
    // LDR BRIGHTNESS BOOST FIX (10% increase in white level)
    patternValue *= 1.1; 

    vec3 newPattern = vec3(patternValue);
    
    // Combine old frame and new pattern (Lighten/Max blend)
    vec3 finalColor = max(prevFrame, newPattern); 
    
    // Ensure Monochrome Output
    float mono = (finalColor.r + finalColor.g + finalColor.b) / 3.0;
    finalColor = vec3(mono);
    
    // Clamp to ensure no overflow
    finalColor = clamp(finalColor, 0.0, 1.0); 

    fragColorOut = vec4(finalColor, 1.0);
}
    </script>
    
    <script>
    window.addEventListener('DOMContentLoaded', () => {
        // --- CONFIGURATION CONSTANTS (All locked defaults) ---
        const CONFIG = {
            U_SCALE: 17730.0, U_DENSITY: 3.0, U_THICKNESS: 1950.0,
            U_SCROLL_SPEED: 38.0, U_WARP_SPEED: 68.0,
            U_RECURSION: 5.0, U_GLITCH_INTENSITY: 25.0,
            INTERNAL_RES: 512,      // FBO resolution
            DISPLAY_SIZE: 1024,     // Canvas display size
            CYCLE_DURATION: 240.0,  // 4 minutes
            FORWARD_PHASE: 120.0,   // 2 minutes
        };
        
        // --- WEBGL SETUP ---
        const canvas = document.getElementById('glslCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            console.error("WebGL 2 not supported!");
            document.body.innerHTML = "Sorry, your browser does not support WebGL 2, which is required for this shader.";
            return; 
        }

        // --- UTILITY FUNCTIONS ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source.trim());
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error("Shader compilation error:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            if (!vertexShader || !fragmentShader) return null;
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
            console.error("Program linking error:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }
        
        function createFBO(gl, width, height) {
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            // Standard LDR texture format
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return { fbo: fbo, texture: texture };
        }

        // --- SHADER COMPILATION & PROGRAM LINKING ---
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
        const feedbackShader = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('feedback-shader').text);
        const drawScreenShader = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('draw-screen-shader').text);
        
        const feedbackProgram = createProgram(gl, vertexShader, feedbackShader);
        const drawScreenProgram = createProgram(gl, vertexShader, drawScreenShader);

        if (!drawScreenProgram || !feedbackProgram) {
            console.error("A required shader program failed to link. Stopping execution.");
            return; 
        }
        
        // --- ANIMATION STATE & FBO SETUP ---
        let currentRotation1 = 0;
        let currentRotation2 = 1;
        let currentGlobalRotation = 0;
        let nextGlobalRotationTime = 0;
        let lastRandomizeTime = 0.0;

        const internalRes = CONFIG.INTERNAL_RES;
        const displayWidth = CONFIG.DISPLAY_SIZE;
        const displayHeight = CONFIG.DISPLAY_SIZE;
        
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        
        let fbo1 = createFBO(gl, internalRes, internalRes);
        let fbo2 = createFBO(gl, internalRes, internalRes);

        // --- FULL SCREEN QUAD SETUP ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // --- UNIFORM LOCATIONS (FEEDBACK) ---
        const fbLocs = {
            iRes: gl.getUniformLocation(feedbackProgram, "iResolution"),
            iTime: gl.getUniformLocation(feedbackProgram, "iTime"),
            uRot1: gl.getUniformLocation(feedbackProgram, "u_rotation1"),
            uRot2: gl.getUniformLocation(feedbackProgram, "u_rotation2"),
            uGlobalRot: gl.getUniformLocation(feedbackProgram, "u_globalRotation"),
            uPrevFrame: gl.getUniformLocation(feedbackProgram, "u_prevFrame"),
            aPosition: gl.getAttribLocation(feedbackProgram, "a_position")
        };
        
        // --- UNIFORM LOCATIONS (DRAW SCREEN) ---
        const dsLocs = {
            iRes: gl.getUniformLocation(drawScreenProgram, "iResolution"),
            uFrame: gl.getUniformLocation(drawScreenProgram, "u_frame"),
            aPosition: gl.getAttribLocation(drawScreenProgram, "a_position")
        };
        
        // --- FIXED UNIFORMS SETUP (Set Once) ---
        (function setFixedUniforms() {
            gl.useProgram(feedbackProgram);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_scale"), CONFIG.U_SCALE);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_density"), CONFIG.U_DENSITY);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_thickness"), CONFIG.U_THICKNESS);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_scrollSpeed"), CONFIG.U_SCROLL_SPEED);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_warpSpeed"), CONFIG.U_WARP_SPEED);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_recursion"), CONFIG.U_RECURSION);
            gl.uniform1f(gl.getUniformLocation(feedbackProgram, "u_glitchIntensity"), CONFIG.U_GLITCH_INTENSITY);
        })();

        // --- ROTATION LOGIC ---
        function randomizeRotations() {
            let r1 = Math.floor(Math.random() * 4);
            let r2;
            do { r2 = Math.floor(Math.random() * 4); } while (r1 === r2);
            currentRotation1 = r1;
            currentRotation2 = r2;
        }
        randomizeRotations();


        function render(time_ms) {
            let totalTime = time_ms * 0.001; 
            
            // Cycle calculation
            const cycleDuration = CONFIG.CYCLE_DURATION;
            const forwardPhaseDuration = CONFIG.FORWARD_PHASE;

            let cycleTime = totalTime % cycleDuration;
            
            // Calculate animationTime (forward 0-120, reverse 120-0)
            let animationTime;
            if (cycleTime <= forwardPhaseDuration) {
                animationTime = cycleTime;
            } else {
                animationTime = forwardPhaseDuration - (cycleTime - forwardPhaseDuration);
            }

            // --- Rotation Randomization ---
            if (totalTime - lastRandomizeTime > 5.0) {
                randomizeRotations();
                lastRandomizeTime = totalTime;
            }
            if (totalTime > nextGlobalRotationTime) {
                currentGlobalRotation = Math.floor(Math.random() * 4);
                nextGlobalRotationTime = totalTime + (Math.random() * 4.0 + 3.0);
            }
            
            // --- STEP 1: Render Feedback/Pattern Shader to FBO 2 ---
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2.fbo);
            gl.viewport(0, 0, internalRes, internalRes);
            gl.useProgram(feedbackProgram);
            
            // Set dynamic uniforms
            gl.uniform2f(fbLocs.iRes, internalRes, internalRes);
            gl.uniform1f(fbLocs.iTime, animationTime); // Pass cyclical time
            gl.uniform1i(fbLocs.uRot1, currentRotation1);
            gl.uniform1i(fbLocs.uRot2, currentRotation2);
            gl.uniform1i(fbLocs.uGlobalRot, currentGlobalRotation);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo1.texture); 
            gl.uniform1i(fbLocs.uPrevFrame, 0);

            // Draw call
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(fbLocs.aPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(fbLocs.aPosition);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // --- STEP 2: Render FBO 2 to the Canvas ---
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, displayWidth, displayHeight);
            gl.useProgram(drawScreenProgram);
            
            // Set draw screen uniforms
            gl.uniform2f(dsLocs.iRes, displayWidth, displayHeight);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo2.texture); 
            gl.uniform1i(dsLocs.uFrame, 0);

            // Draw call
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(dsLocs.aPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(dsLocs.aPosition);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // --- STEP 3: Swap FBOs for next frame ---
            [fbo1, fbo2] = [fbo2, fbo1];

            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
    });
    </script>
</body>
</html>
